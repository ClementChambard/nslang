#include mem.nsh
#include darray.nsh

fn DArray::init(self: DArray*) {
  self->data = nullptr;
  self->len = 0;
  self->capacity = 0;
}

fn DArray::destroy(self: DArray*) {
  if (self->data) free(self->data);
  self->data = nullptr;
  self->len = 0;
  self->capacity = 0;
}

fn DArray::__increase_capacity(self: DArray*) {
  if (self->capacity == 0) {
    self->capacity = 4;
  } else {
    self->capacity *= 2;
  }
  let new_size = self->capacity * sizeof(void*);
  self->data = realloc(self->data, new_size);
}

fn DArray::push(self: DArray*, value: void*) {
  if (self->len + 1 > self->capacity) {
    self->__increase_capacity();
  }
  self->data[self->len] = value;
  self->len++;
}

fn DArray::pop(self: DArray*) -> void* {
  if (self->len == 0) return nullptr;
  return self->data[--self->len];
}

fn DArray::pop_front(self: DArray*) -> void* {
  if (self->len == 0) return nullptr;
  let to_return = self->data[0];
  self->erase(0);
  return to_return;
}

fn DArray::erase(self: DArray*, pos: i64) {
  let i = pos;
  while (i < self->len - 1) {
      self->data[i] = self->data[i+1];
      i += 1;
  }
  self->len--;
}

fn DArray::erase_it(self: DArray*, pos: void**) {
  let end = &(self->end())[-1];
  while (pos < end) {
      pos[0] = pos[1];
      pos = &pos[1];
  }
  self->len--;
}

fn DArray::begin(self: DArray*) -> void** {
  return self->data;
}

fn DArray::end(self: DArray*) -> void** {
  return &self->data[self->len];
}

fn range_find(begin: void**, end: void**, value: void*) -> void** {
  while (begin != end) {
    if (*begin == value) return begin;
    begin = &begin[1];
  }
  return end;
}
