#include diags.nsh
#include io.nsh
#include str.nsh
#include opened_file.nsh

fn fatal_error(msg: i8*) {
    print("\x1b[1;32mfatal error: \x1b[0;1m%s\x1b[0m\n", msg);
    __builtin_syscall(60, 1);
}

let __last_loc: Loc;
let __last_level: i64;
let __had_errors: bool;

fn push_level_color(os: String*, level: i64, bold: bool) {
    os->push_cstr("\x1b[");
    if (bold) os->push_cstr("1;");
    if (level == DIAG_WARNING) os->push_cstr("35m");
    else if (level == DIAG_NOTE) os->push_cstr("34m");
    else if (level == DIAG_ERROR) os->push_cstr("31m");
    else if (level == DIAG_UNIMPLEMENTED) os->push_cstr("31m");
    else os->push_cstr("37m");
}

fn push_diagnostic_level(os: String*, level: i64, show_colors: bool) {
    if (show_colors) push_level_color(os, level, true);
    if (level == DIAG_WARNING) os->push_cstr("warning: ");
    else if (level == DIAG_NOTE) os->push_cstr("note: ");
    else if (level == DIAG_ERROR) os->push_cstr("error: ");
    else if (level == DIAG_UNIMPLEMENTED) os->push_cstr("unimplemented: ");
    else os->push_cstr("UNKDIAG: ");
    if (show_colors) os->push_cstr("\x1b[0m");
}

fn push_diagnostic_message(os: String*, is_supplemental: bool, message: i8*, current_column: i64, columns: i64, show_colors: bool) {
    let bold: bool;
    bold = false;
    if (show_colors) if (!is_supplemental) {
        os->push_cstr("\x1b[1m");
        bold = true;
    }
    if (columns != 0) {
        // TODO:
        // push_word_wrapped(os, message, columns, current_column, bold);
    } else {
        os->push_cstr(message);
    }
    if (show_colors) os->push_cstr("\x1b[0m");
    os->push('\n');
}

fn push_filename(os: String*, filename: i8*) {
    os->push_cstr(filename);
}

fn push_diagnostic_loc(os: String*, loc: Loc, level: i64) {
    let complete_loc: CompleteLoc;
    OpenedFile::get_loc(&complete_loc, loc);
    push_level_color(os, level, true);
    push_filename(os, complete_loc.filename);
    os->push_format(":%i:%i: ", complete_loc.line, complete_loc.col);
}

fn emit_diagnostic_message(loc: Loc, level: i64, msg: i8*) {
    let os: String;
    os.init();
    if (loc != 0) {
        push_diagnostic_loc(&os, loc, level);
    }
    push_diagnostic_level(&os, level, true);
    push_diagnostic_message(&os, level == DIAG_NOTE, msg, 0, 0, true);
    print("%S", &os);
    os.destroy();
}

fn emit_code_context(loc: Loc, level: i64, ranges: LocRge*, ranges_count: i64, hints: void*, hint_count: i64) {
    print("Code ctx\n");
}

fn Diag::emit(self: Diag*) {
    emit_diagnostic_message(self->loc, self->level, self->msg);
    emit_code_context(self->loc, self->level, cast<LocRge*>(self->ranges.data), self->ranges.len / 2, self->hints.data, self->hints.len);
    __last_loc = self->loc;
    __last_level = self->level;
    if (__last_level == DIAG_ERROR) __had_errors = true;
}

fn reset_errors() {
    __had_errors = false;
}

fn compilation_had_errors() -> bool {
    return __had_errors;
}

fn Diag::init(self: Diag*, loc: Loc, msg: i8*, level: i64) {
    self->loc = loc;
    self->msg = msg;
    self->level = level;
    self->ranges.init();
    self->hints.init();
}

fn Diag::add_range(self: Diag*, rge: LocRge*) {
    self->ranges.push(cast<void*>(rge->start));
    self->ranges.push(cast<void*>(rge->end));
}

fn Diag::destroy(self: Diag*) {
    self->ranges.destroy();
    self->hints.destroy();
}

fn diag(loc: Loc, msg: i8*, level: i64) {
    let d: Diag;
    d.init(loc, msg, level);
    d.emit();
    d.destroy();
}
