#include ir_data.nsh
#include mem.nsh
#include io.nsh

fn IR::opcode_name(opcode: IrInstrKind) -> i8* {
  if (opcode == IR_STV) return cast<i8*>("STV");
  if (opcode == IR_STA) return cast<i8*>("STA");
  if (opcode == IR_LDA) return cast<i8*>("LDA");
  if (opcode == IR_PSH) return cast<i8*>("PSH");
  if (opcode == IR_DUP) return cast<i8*>("DUP");
  if (opcode == IR_DRP) return cast<i8*>("DRP");
  if (opcode == IR_VAA) return cast<i8*>("VAA");
  if (opcode == IR_LBL) return cast<i8*>("LBL");
  if (opcode == IR_JMP) return cast<i8*>("JMP");
  if (opcode == IR_JZO) return cast<i8*>("JZO");
  if (opcode == IR_JNZ) return cast<i8*>("JNZ");
  if (opcode == IR_CAL) return cast<i8*>("CAL");
  if (opcode == IR_BUI) return cast<i8*>("BUI");
  if (opcode == IR_RET) return cast<i8*>("RET");
  if (opcode == IR_RTV) return cast<i8*>("RTV");
  if (opcode == IR_NEG) return cast<i8*>("NEG");
  if (opcode == IR_INV) return cast<i8*>("INV");
  if (opcode == IR_NOT) return cast<i8*>("NOT");
  if (opcode == IR_ADD) return cast<i8*>("ADD");
  if (opcode == IR_SUB) return cast<i8*>("SUB");
  if (opcode == IR_MUL) return cast<i8*>("MUL");
  if (opcode == IR_DIV) return cast<i8*>("DIV");
  if (opcode == IR_REM) return cast<i8*>("REM");
  if (opcode == IR_SHL) return cast<i8*>("SHL");
  if (opcode == IR_SHR) return cast<i8*>("SHR");
  if (opcode == IR_AND) return cast<i8*>("AND");
  if (opcode == IR_XOR) return cast<i8*>("XOR");
  if (opcode == IR_IOR) return cast<i8*>("IOR");
  if (opcode == IR_LTH) return cast<i8*>("LTH");
  if (opcode == IR_GTH) return cast<i8*>("GTH");
  if (opcode == IR_LEQ) return cast<i8*>("LEQ");
  if (opcode == IR_GEQ) return cast<i8*>("GEQ");
  if (opcode == IR_EQU) return cast<i8*>("EQU");
  if (opcode == IR_NEQ) return cast<i8*>("NEQ");
  return cast<i8*>("UNK");
}

fn IrInstr::destroy(self: IrInstr*) {
  if (self->operand_str != nullptr)
    free(self->operand_str);
}

fn IrInstr::move_from(self: IrInstr*, other: IrInstr*) {
  if (self->operand_str != nullptr)
    free(self->operand_str);
  self->operand_str = other->operand_str;
  self->opcode = other->opcode;
  self->operand1 = other->operand1;
  self->operand2 = other->operand2;
  other->operand_str = nullptr;
}

fn IrInstr::special_arg_str(self: IrInstr*, out: String*) {
  if (self->operand1 == IR_OPK_IMM) {
    out->push_format("    %i\n", self->operand2);
  } else if (self->operand1 == IR_OPK_VAR) {
    out->push_format("    Var[%i]\n", self->operand2);
  } else if (self->operand1 == IR_OPK_ADDR) {
    out->push_format("    [%i]\n", self->operand2);
  } else if (self->operand1 == IR_OPK_GLOB_ADDR) {
    out->push_format("    [global_%i]\n", self->operand2);
  } else if (self->operand1 == IR_OPK_GLOB_I64) {
    out->push_format("    Var[global_%i]\n", self->operand2);
  } else {
    out->push('\n');
  }
}

fn IrInstr::to_str(self: IrInstr*, out: String*) {
  if (self->opcode == IR_LBL) {
    out->push_format(" .%s\n", self->operand_str);
    return;
  }
  out->push_format("    %s", IR::opcode_name(self->opcode));
  let operand_count: i64;
  operand_count = 0;
  if (self->opcode >= IR_ADD) {
    self->special_arg_str(out);
  } else if (self->opcode == IR_PSH) {
    self->special_arg_str(out);
  } else if (self->opcode == IR_CAL) {
    out->push_format("    %s, %i\n", self->operand_str, self->operand2);
  } else if (self->opcode == IR_BUI) {
    out->push_format("    %s, %i\n", self->operand_str, self->operand2);
  } else if (self->opcode == IR_JMP) {
    out->push_format("    %s\n", self->operand_str);
  } else if (self->opcode == IR_JNZ) {
    out->push_format("    %s\n", self->operand_str);
  } else if (self->opcode == IR_JZO) {
    out->push_format("    %s\n", self->operand_str);
  } else if (self->opcode == IR_STV) {
    out->push_format("    %i\n", self->operand1);
  } else if (self->opcode == IR_STA) {
    out->push_format("    %i\n", self->operand1);
  } else if (self->opcode == IR_LDA) {
    out->push_format("    %i\n", self->operand1);
  } else if (self->opcode == IR_VAA) {
    out->push_format("    %i\n", self->operand1);
  } else {
    out->push('\n');
  }
}

fn IrGlobal::destroy(self: IrGlobal*) {
  if (self->data != nullptr) free(self->data);
  if (self->name != nullptr) free(self->name);
}

fn StackFrameEntry::destroy(self: StackFrameEntry*) {
  if (self->name != nullptr) free(self->name);
}

fn IrFunc::destroy(self: IrFunc*) {
  let i: i64;
  i = 0; while (i < self->stack_frame_len) { self->stack_frame[i].destroy(); i += 1; }
  i = 0; while (i < self->instructions_len) { self->instructions[i].destroy(); i += 1; }
  if (self->name != nullptr) free(self->name);
  if (self->params != nullptr) free(self->params);
  if (self->stack_frame != nullptr) free(self->stack_frame);
  if (self->instructions != nullptr) free(self->instructions);
}

fn FullIr::has_global(self: FullIr*, name: CStr) -> i64 {
  let i: i64;
  i = 0;
  while (i < self->globs_len) {
    if (strcmp(self->globs[i].name, name) == 0) return i;
    i += 1;
  }
  return -1;
}

fn FullIr::destroy(self: FullIr*) {
  let i: i64;
  i = 0; while (i < self->functions_len) { self->functions[i].destroy(); i += 1; }
  i = 0; while (i < self->globs_len) { self->globs[i].destroy(); i += 1; }
  if (self->functions != nullptr) free(self->functions);
  if (self->globs != nullptr) free(self->globs);
}

fn FullIr::print(self: FullIr*) {
  let i: i64;
  let j: i64;
  let ins_str: String;

  ins_str.init();

  i = 0;
  while (i < self->functions_len) {
    let fun: IrFunc*;
    fun = &self->functions[i];
    if (fun->instructions_len == 0) {
      if (fun->is_lib) {
        print("lib %s\n", fun->name);
      }
      continue;
    }
    if (fun->is_lib) print("lib ");
    print("%s:", fun->name);
    if (fun->returns_value) print("\n  @returns");
    if (fun->is_vararg) print("\n  @vararg");
    if (fun->params_len > 0) {
      print("\n  @params(");
      j = 0;
      while (j < fun->params_len) {
        if (fun->params[j].is_float) print("f");
        else print("i");
        j += 1;
      }
      print(")");
    }

    j = 0;
    while (j < fun->stack_frame_len) {
      print("\n  @var[%i](%s-%i-%i)", j, fun->stack_frame[j].name, fun->stack_frame[j].size, fun->stack_frame[j].align);
      j += 1;
    }
    print("\n");

    j = 0;
    while (j < fun->instructions_len) {
      ins_str.clear();
      fun->instructions[j].to_str(&ins_str);
      print("%S", &ins_str);
      j += 1;
    }
    i += 1;
  }

  ins_str.destroy();

  i = 0;
  while (i < self->globs_len) {
    print("global %i:\n    ", i);
    j = 0;
    while (j < self->globs[i].data_len) {
      print("%x ", self->globs[i].data[j]);
      j += 1;
    }
    print("\n");
    i += 1;
  }
}
