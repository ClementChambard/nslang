#include ir_interpreter.nsh
#include mem.nsh
#include io.nsh

fn __write_sized_int(addr: u8*, int: i64, size: i64) {
  if (addr == nullptr) return;
  if (size == 1) *addr = int;
  if (size == 2) *cast<i16*>(addr) = int;
  if (size == 4) *cast<i32*>(addr) = int;
  if (size == 8) *cast<i64*>(addr) = int;
}

fn __read_sized_int(addr: u8*, size: i64) -> i64 {
  if (addr == nullptr) return 0;
  if (size == 1) return *addr;
  if (size == 2) return *cast<i16*>(addr);
  if (size == 4) return *cast<i32*>(addr);
  if (size == 8) return *cast<i64*>(addr);
}

fn __to_u32(x: i64) -> i64 {
  return (x << 0x20) >> 0x20;
}

fn MemKind::offset(k: eMemKind) -> i64 { return k * 0x10000 * 0x10000; }
fn MemKind::addr_offs(addr: i64) -> i64 { return __to_u32(addr); }
fn MemKind::addr_kind(addr: i64) -> eMemKind { return addr >> 0x20; }

fn ExecCtx::init(self: ExecCtx*, f: IrFunc*, base_stack_offset: i64) {
  self->f = f;
  self->cur_instr = -1;
  self->base_stack_offset = base_stack_offset;
  self->vars_len = f->stack_frame_len;
  self->vars = malloc(self->vars_len * sizeof(i64));
  self->cur_vaa = 0;
  self->prev_ctx = nullptr;
  self->va_args_len = 0;
  self->va_args = nullptr;

  let i: i64;
  i = 0;
  while (i < self->vars_len) {
    self->vars[i] = __to_u32(f->stack_frame[i].size) + (__to_u32(base_stack_offset) << 0x20);
    base_stack_offset += f->stack_frame[i].size;
    i += 1;
  }
}

fn InterpMemory::change_size(self: InterpMemory*, new_size: i64) {
  if (self->data_len >= new_size) {
    self->data_len = new_size;
    return;
  }
  if (self->data_len == 0) {
    self->capacity = 0x100;
    if (new_size > 0x100) self->capacity = new_size;
    self->data = malloc(self->capacity);
    self->data_len = new_size;
    return;
  }
  while (self->capacity < new_size) {
    self->capacity = self->capacity << 1;
  }
  self->data = realloc(self->data, self->capacity);
  self->data_len = new_size;
}

fn ExecCtx::setup_stack(self: ExecCtx*, stack: InterpMemory*, args: i64*, arg_count: i64) {
  let i: i64;
  let regular_param_count: i64;

  // setup va_args
  regular_param_count = self->f->params_len;
  self->va_args_len = arg_count - regular_param_count;
  self->va_args = malloc(self->va_args_len * sizeof(i64));
  i = 0; while (i < self->va_args_len) { self->va_args[i] = args[i + regular_param_count]; i += 1; }

  // prepare stack memory
  let added_size: i64;
  let old_size: i64;
  old_size = stack->data_len;
  added_size = 0;
  i = 0; while (i < self->vars_len) { added_size += __to_u32(self->vars[i]); i += 1; }
  stack->change_size(stack->data_len + added_size);

  // fill in arguments
  i = 0;
  while (i < regular_param_count) {
    let arg_size: i64;
    arg_size = __to_u32(self->vars[i]);
    __write_sized_int(&stack->data[old_size], args[i], arg_size);
    old_size += arg_size;
    i += 1;
  }

  // zero out local variables
  memset(&stack->data[old_size], 0, stack->capacity - old_size);
}

fn ExecCtx::destroy(self: ExecCtx*) {
  if (self->vars != nullptr) free(self->vars);
  if (self->va_args != nullptr) free(self->va_args);
  if (self->prev_ctx != nullptr) {
    self->prev_ctx->destroy();
    free(self->prev_ctx);
  }
}

fn __find_function(ir: FullIr*, name: i8*) -> IrFunc* {
  let i: i64;
  i = 0;
  while (i < ir->functions_len) {
    if (strcmp(ir->functions[i].name, name) == 0) {
      return &ir->functions[i];
    }
    i += 1;
  }
  return nullptr;
}

fn InterpMemory::destroy(self: InterpMemory*) { if (self->data != nullptr) free(self->data); }


fn Interpreter::__prepare_globals(self: Interpreter*) {
  let i: i64;
  let mem: InterpMemory*;

  mem = &self->memory[MK_GLOB];
  self->globals_len = self->ir->globs_len;
  self->globals = malloc(self->globals_len * sizeof(i64));
  i = 0; while (i < self->globals_len) {
    self->globals[i] = __to_u32(self->ir->globs[i].data_len) + (__to_u32(mem->capacity) << 0x20);
    mem->capacity = mem->capacity + self->ir->globs[i].data_len;
    i += 1;
  }

  mem->data = malloc(mem->capacity);
  i = 0; while (i < self->globals_len) {
    memcpy(&mem->data[mem->data_len], self->ir->globs[i].data, self->ir->globs[i].data_len);
    mem->data_len = mem->data_len + self->ir->globs[i].data_len;
    i += 1;
  }
}

fn Interpreter::init(self: Interpreter*, ir: FullIr*) {
  let i: i64;
  i = 0; while (i < MK_COUNT) {
    self->memory[i].data = nullptr;
    self->memory[i].data_len = 0;
    self->memory[i].capacity = 0;
    i += 1;
  }
  self->globals = nullptr;
  self->globals_len = 0;
  self->ir = ir;
  self->__prepare_globals();
  self->ctx = malloc(sizeof(ExecCtx));
  self->ctx->init(__find_function(ir, "main"), 0i64);
  self->ctx->setup_stack(&self->memory[MK_STACK], nullptr, 0i64);
  self->exit_code = 0;
  self->done = false;
}

fn Interpreter::destroy(self: Interpreter*) {
  let i: i64;
  i = 0; while (i < MK_COUNT) { self->memory[i].destroy(); i += 1; }
  if (self->globals != nullptr) free(self->globals);
  self->ctx->destroy();
  free(self->ctx);
}

fn Interpreter::__mem(self: Interpreter*, addr: i64) -> void* {
  return &self->memory[MemKind::addr_kind(addr)].data[MemKind::addr_offs(addr)];
}

fn Interpreter::__syscall(self: Interpreter*, n: i64, args: i64*, arg_count: i64) -> i64 {
  if (n == 0) { // read
    return __builtin_syscall(n, args[0], self->__mem(args[1]), args[2]);
  } else if (n == 1) { // write
    return __builtin_syscall(n, args[0], self->__mem(args[1]), args[2]);
  } else if (n == 2) { // open
    return __builtin_syscall(n, self->__mem(args[0]), args[1], args[2]);
  } else if (n == 3) { // close
    return __builtin_syscall(n, args[0]);
  } else if (n == 8) { // lseek
    return __builtin_syscall(n, args[0], args[1], args[2]);
  } else if (n == 12) { // brk
    let cur_brk: i64;
    let new_brk: i64;
    cur_brk = self->memory[MK_HEAP].data_len;
    new_brk = args[0] - MemKind::offset(MK_HEAP);
    if (new_brk > cur_brk) {
      self->memory[MK_HEAP].change_size(new_brk);
    }
    return self->memory[MK_HEAP].data_len + MemKind::offset(MK_HEAP);
  } else {
    print("syscall[%i](%i args)\n", n, arg_count);
    return 0;
  }
}

fn Interpreter::__push(self: Interpreter*, val: i64) {
  let memory: InterpMemory*;
  memory = &self->memory[MK_STACK];
  memory->change_size(memory->data_len + 8);
  *cast<i64*>(&memory->data[memory->data_len - 8]) = val;
}

fn Interpreter::__pop(self: Interpreter*) -> i64 {
  let memory: InterpMemory*;
  memory = &self->memory[MK_STACK];
  memory->change_size(memory->data_len - 8);
  return *cast<i64*>(&memory->data[memory->data_len]);
}

fn Interpreter::__call(self: Interpreter*, fname: i8*, arg_count: i64) {
  let i: i64;
  let args: i64*;
  args = malloc(arg_count * sizeof(i64));

  i = 0; while (i < arg_count) { args[i] = self->__pop(); i += 1; }

  let new_ctx: ExecCtx*;
  new_ctx = malloc(sizeof(ExecCtx));
  new_ctx->init(__find_function(self->ir, fname), self->memory[MK_STACK].data_len);
  new_ctx->prev_ctx = self->ctx;
  self->ctx = new_ctx;
  self->ctx->setup_stack(&self->memory[MK_STACK], args, arg_count);

  free(args);
}

fn Interpreter::__ret(self: Interpreter*, return_value: bool) {
  let ret_val: i64;
  ret_val = 0;
  if (return_value) {
    ret_val = self->__pop();
  }
  self->memory[MK_STACK].change_size(self->ctx->base_stack_offset);
  if (self->ctx->prev_ctx == nullptr) {
    self->done = true;
    self->exit_code = ret_val;
    return;
  }
  let old_ctx: ExecCtx*;
  old_ctx = self->ctx;
  self->ctx = old_ctx->prev_ctx;
  free(old_ctx);
  if (return_value) {
    self->__push(ret_val);
  }
}

fn Interpreter::__jump(self: Interpreter*, lbl: i8*) {
  let i: i64;
  let f: IrFunc*;
  i = 0;
  f = self->ctx->f;

  while (i < f->instructions_len) {
    if (f->instructions[i].opcode == IR_LBL) if (strcmp(f->instructions[i].operand_str, lbl) == 0) {
      self->ctx->cur_instr = i;
      return;
    }
    i += 1;
  }
  // error: label not found
  self->ctx->cur_instr = -1;
}

fn Interpreter::__exec_builtin(self: Interpreter*, name: i8*, arg_count: i64) {
  let i: i64;
  let args: i64*;
  args = malloc(arg_count * sizeof(i64));
  i = 0; while (i < arg_count) { args[i] = self->__pop(); i += 1; }
  if (strcmp(name, "__builtin_syscall") == 0) {
    self->__push(self->__syscall(args[0], &args[1], arg_count - 1));
  } else {
    print("UNKNOWN BUILTIN CALLED: '%s'\n", name);
  }
  free(args);
}

fn Interpreter::__store_bytes(self: Interpreter*, addr: i64, bytes: u8*, bytes_len: i64) {
  memcpy(self->__mem(addr), bytes, bytes_len);
}

fn Interpreter::__store(self: Interpreter*, size: i64, addr: i64, val: i64) {
  if (size == 1) {
    let val_u8: u8;
    val_u8 = val;
    self->__store_bytes(addr, &val_u8, 1);
  } else if (size == 2) {
    let val_u16: u16;
    val_u16 = val;
    self->__store_bytes(addr, cast<u8*>(&val_u16), 2);
  } else if (size == 4) {
    let val_u32: u32;
    val_u32 = val;
    self->__store_bytes(addr, cast<u8*>(&val_u32), 4);
  } else if (size == 8) {
    self->__store_bytes(addr, cast<u8*>(&val), 8);
  }
}

fn Interpreter::__load_bytes(self: Interpreter*, addr: i64, buf: u8*, load_size: i64) {
  memcpy(buf, self->__mem(addr), load_size);
}

fn Interpreter::__load(self: Interpreter*, size: i64, addr: i64) -> i64 {
  if (size == 1) {
    let val_u8: u8;
    self->__load_bytes(addr, &val_u8, 1);
    return val_u8;
  } else if (size == 2) {
    let val_u16: u16;
    self->__load_bytes(addr, cast<u8*>(&val_u16), 2);
    return val_u16;
  } else if (size == 4) {
    let val_u32: u32;
    self->__load_bytes(addr, cast<u8*>(&val_u32), 4);
    return val_u32;
  } else if (size == 8) {
    let val_i64: i64;
    self->__load_bytes(addr, cast<u8*>(&val_i64), 8);
    return val_i64;
  }
  return 0;
}

fn Interpreter::__get_thing(self: Interpreter*, operand1: i64, operand2: i64) -> i64 {
  if (operand1 == IR_OPK_IMM) {
    return operand2;
  } else if (operand1 == IR_OPK_VAR) {
    let var: i64;
    var = self->ctx->vars[operand2];
    return self->__load(__to_u32(var), MemKind::offset(MK_STACK) + (var >> 0x20));
  } else if (operand1 == IR_OPK_ADDR) {
    return MemKind::offset(MK_STACK) + (self->ctx->vars[operand2] >> 0x20);
  } else if (operand1 == IR_OPK_GLOB_ADDR) {
    return MemKind::offset(MK_GLOB) + (self->globals[operand2] >> 0x20);
  } else if (operand1 == IR_OPK_GLOB_I64) {
    return MemKind::offset(MK_GLOB) + (self->globals[operand2] >> 0x20);
    return self->__load(__to_u32(self->globals[operand2]), MemKind::offset(MK_GLOB) + (self->globals[operand2] >> 0x20));
  } else {
    return 0;
  }
}

fn Interpreter::__exec_instr(self: Interpreter*, ins: IrInstr*) {
  if (ins->opcode == IR_STV) {
    let val: i64;
    let var: i64;
    val = self->__pop();
    var = self->ctx->vars[ins->operand1];
    self->__store(__to_u32(var), MemKind::offset(MK_STACK) + (var >> 0x20), val);
  } else if (ins->opcode == IR_STA) {
    let addr: i64;
    let val: i64;
    addr = self->__pop();
    val = self->__pop();
    self->__store(ins->operand1, addr, val);
  } else if (ins->opcode == IR_LDA) {
    self->__push(self->__load(ins->operand1, self->__pop()));
  } else if (ins->opcode == IR_PSH) {
    self->__push(self->__get_thing(ins->operand1, ins->operand2));
  } else if (ins->opcode == IR_DUP) {
    let val: i64;
    val = self->__pop();
    self->__push(val);
    self->__push(val);
  } else if (ins->opcode == IR_DRP) {
    self->__pop();
  } else if (ins->opcode == IR_VAA) {
    self->__push(self->ctx->va_args[self->ctx->cur_vaa]);
    self->ctx->cur_vaa = self->ctx->cur_vaa + 1;
  } else if (ins->opcode == IR_LBL) {
  } else if (ins->opcode == IR_JMP) {
    self->__jump(ins->operand_str);
  } else if (ins->opcode == IR_JZO) {
    if (self->__pop() == 0) self->__jump(ins->operand_str);
  } else if (ins->opcode == IR_JNZ) {
    if (self->__pop() != 0) self->__jump(ins->operand_str);
  } else if (ins->opcode == IR_CAL) {
    self->__call(ins->operand_str, ins->operand2);
  } else if (ins->opcode == IR_BUI) {
    self->__exec_builtin(ins->operand_str, ins->operand2);
  } else if (ins->opcode == IR_RET) {
    self->__ret(false);
  } else if (ins->opcode == IR_RTV) {
    self->__ret(true);
  } else if (ins->opcode == IR_NEG) {
    self->__push(-self->__pop());
  } else if (ins->opcode == IR_NOT) {
    self->__push(!self->__pop());
  } else if (ins->opcode == IR_INV) {
    self->__push(~self->__pop());
  } else if (ins->opcode >= IR_ADD) {
    let a: i64;
    let b: i64;
    let res: i64;
    if (ins->operand1 == IR_OPK_NONE) {
      b = self->__pop();
    } else {
      b = self->__get_thing(ins->operand1, ins->operand2);
    }
    a = self->__pop();
    if (ins->opcode == IR_ADD)
        res = a + b;
    if (ins->opcode == IR_SUB)
        res = a - b;
    if (ins->opcode == IR_MUL)
        res = a * b;
    if (ins->opcode == IR_DIV)
        res = a / b;
    if (ins->opcode == IR_REM)
        res = a % b;
    if (ins->opcode == IR_SHL)
        res = a << b;
    if (ins->opcode == IR_SHR)
        res = a >> b;
    if (ins->opcode == IR_AND)
        res = a & b;
    if (ins->opcode == IR_XOR)
        res = a ^ b;
    if (ins->opcode == IR_IOR)
        res = a | b;
    if (ins->opcode == IR_LTH)
        res = a < b;
    if (ins->opcode == IR_GTH)
        res = a > b;
    if (ins->opcode == IR_LEQ)
        res = a <= b;
    if (ins->opcode == IR_GEQ)
        res = a >= b;
    if (ins->opcode == IR_EQU)
        res = a == b;
    if (ins->opcode == IR_NEQ)
        res = a != b;
    self->__push(res);
  }
}

fn Interpreter::run(self: Interpreter*) {
  while (!self->done) {
    self->ctx->cur_instr = self->ctx->cur_instr + 1;
    self->__exec_instr(&self->ctx->f->instructions[self->ctx->cur_instr]);
  }
}

fn __input(out: String*) {
  let buf: i8[0x11];
  let n_read: i64;
  n_read = read(STDIN, buf, 0x10);
  if (n_read == 1) if (buf[0] == '\n') return;
  out->clear();
  buf[n_read] = 0;
  out->push_cstr(buf);
  // maybe read more...
}

fn __strcmp2(s: String*, s1: i8*, s2: i8*) -> bool {
  if (strcmp(s->inner.data, s1) == 0) return true;
  if (strcmp(s->inner.data, s2) == 0) return true;
  return false;
}

fn __cmd_args(arg_str: String*) -> i8* {
  let i: i64;
  i = 0;
  while (true) {
    if (arg_str->inner[i] == 0) {
      return nullptr;
    }
    if (arg_str->inner[i] == ' ') break;
    i += 1;
  }
  arg_str->inner[i] = 0;
  return &arg_str->inner[i+1];
}

struct ExecPoint {
  f: IrFunc*;
  ins_id: i64;
};

fn __call_stack_navigate(cur_ctx: ExecCtx**, ctx_list: ExecCtx*, dir: i64) -> bool {
  if (dir == -1) {
    if ((*cur_ctx)->prev_ctx == nullptr) {
      print("Can't go any more up\n");
      return false;
    }
    *cur_ctx = (*cur_ctx)->prev_ctx;
    return true;
  }
  if (*cur_ctx == ctx_list) {
    print("Can't go any more down\n");
    return false;
  }
  while (ctx_list->prev_ctx != *cur_ctx) ctx_list = ctx_list->prev_ctx;
  *cur_ctx = ctx_list;
  return true;
}

fn __print_call_stack(cur_ctx: ExecCtx*, ctx_list: ExecCtx*) {
  let start: i8*;
  let word: i8*;

  word = "  at";
  while (ctx_list != nullptr) {
    if (ctx_list == cur_ctx) start = "->";
    else start = "  ";
    print("%s %s %s:%i\n", start, word, ctx_list->f->name, ctx_list->cur_instr);
    ctx_list = ctx_list->prev_ctx;
    word = "from";
  }
}

fn __print_stack(ctx: ExecCtx*, stack_memory: InterpMemory*) {
  print("Stack variables:\n");
//     for ent, (o, s) in zip(ctx.cur_function.stack_frame, ctx.local_offsets):
//         addr = o + MemKind.STACK.offset()
//         data = stack_memory[o : o + s]
//         print(f"  #{addr:09X} ({ent.name}): {data}")
//     end_o = 0
//     if len(ctx.local_offsets) > 0:
//         end_o = ctx.local_offsets[-1][0] + ctx.local_offsets[-1][1]
//     stack = stack_memory[end_o:]
//     stack_count = (len(stack_memory) - end_o) // 8
//     print("Stack:")
//     for i in range(stack_count):
//         name = f"STACK-{stack_count - i + 1}"
//         addr = MemKind.STACK.offset() + end_o + i * 8
//         d = struct.unpack("Q", stack[i * 8 : i * 8 + 8])[0]
//         print(f"  #{addr:09X} ({name}): 0x{d:X}")
}

fn __print_globals(globals: i64*, globals_len: i64, memory: InterpMemory*) {
  if (globals_len == 0) {
    print("No global variables.\n");
    return;
  }
  print("Global variables:\n");
  let i: i64;
  i = 0;
  while (i < globals_len - 1) {
//         n = globals[i][1]
//         o = globals[i][0]
//         s = globals[i + 1][0] - o
//         addr = o + MemKind::offset(MK_GLOB);
//         data = memory[o : o + s]
//         print(f"  #{addr:09X} ({n}): {data}")
    i += 1;
  }
//     n = globals[i][1]
//     o = globals[i][0]
//     addr = o + MemKind::offset(MK_GLOB);
//     data = memory[o:]
//     print(f"  #{addr:09X} ({n}): {data}")
}

fn Interpreter::debug(self: Interpreter*) {
  let print_ins: bool;
  let cur_ctx: ExecCtx*;
  let breakpoints: ExecPoint*;
  let breakpoints_len: i64;
  let run_until: ExecPoint;
  let running: bool;
  let last: String;
  let tmp_str: String;
  let i: i64;
  let args: i8*;

  print_ins = true;
  cur_ctx = self->ctx;
  breakpoints = nullptr;
  breakpoints_len = 0;
  run_until.f = nullptr;
  run_until.ins_id = 0;
  running = false;
  last.init();
  tmp_str.init();
  args = nullptr;

  while (true) {
    if (self->done) {
      print ("Program exited with code %i\n", self->exit_code);
      print("Type 'exit' to quit, or 'restart' to restart the program\n");
      running = false;
      while (true) {
        __input(&last);
        if (strcmp(last.inner.data, "exit") == 0) {
          return;
        }
        if (__strcmp2(&last, "r", "restart")) {
          self->done = false;
//                         self.memory = [b"", b"", b"", b""]
//                         self.ctx = ExecCtx("main", self.functions["main"])
//                         self.memory[MemKind.STACK.value] = self.ctx.setup_stack([])
//                         self.prepare_globals(self.ir_globals)
          break;
        }
      }
      print_ins = true;
      cur_ctx = self->ctx;
      continue;
    }
    if (running) {
      self->ctx->cur_instr = self->ctx->cur_instr + 1;
      self->__exec_instr(&self->ctx->f->instructions[self->ctx->cur_instr]);
      if (run_until.f != nullptr) {
        if (run_until.f == self->ctx->f) if (run_until.ins_id == self->ctx->cur_instr) {
          running = false;
          print_ins = true;
          run_until.f = nullptr;
          cur_ctx = self->ctx;
          continue;
        }
      }
      i = 0; while (i < breakpoints_len) {
        if (breakpoints[i].f == self->ctx->f) if (breakpoints[i].ins_id == self->ctx->cur_instr) {
          running = false;
          print_ins = true;
          run_until.f = nullptr;
          cur_ctx = self->ctx;
          print("Hit breakpoint[%i] at %s:%i\n", i, breakpoints[i].f->name, breakpoints[i].ins_id + 1);
          break;
        }
        i += 1;
      }
      continue;
    }
    if (print_ins) {
      print("%s:%i\n", cur_ctx->f->name, cur_ctx->cur_instr + 1);
      tmp_str.clear();
      cur_ctx->f->instructions[cur_ctx->cur_instr + 1].to_str(&tmp_str);
      print("%S", &tmp_str);
      print_ins = false;
    }
    if (args != nullptr) {
      args[-1] = ' ';
    }
    __input(&last);
    args = __cmd_args(&last);
    if (__strcmp2(&last, "n", "next")) {
      self->ctx->cur_instr = self->ctx->cur_instr + 1;
      self->__exec_instr(&self->ctx->f->instructions[self->ctx->cur_instr]);
      print_ins = true;
      cur_ctx = self->ctx;
    } else if (__strcmp2(&last, "c", "continue")) {
      running = true;
    } else if (__strcmp2(&last, "b", "break")) {
//                 args = cmd.split(" ")[1:]
//                 fst_arg_is_line = False
//                 line = -1
//                 fn = cur_ctx.f_name
//                 if len(args) > 0:
//                     if args[0][0].isdigit():
//                         line = int(args[0]) - 1
//                         fst_arg_is_line = True
//                     else:
//                         fn = args[0]
//                 if len(args) > 1:
//                     if fst_arg_is_line:
//                         fn = args[1]
//                     else:
//                         line = int(args[1]) - 1
//                 print(f"Added breakpoint[{len(breakpoints)}] at {fn}:{line + 1}")
//                 breakpoints.append((fn, line))
//                 continue
    } else if (__strcmp2(&last, "s", "step")) {
      run_until.f = self->ctx->f;
      run_until.ins_id = self->ctx->cur_instr + 1;
      running = true;
    } else if (__strcmp2(&last, "so", "stepout")) {
      if (self->ctx->prev_ctx == nullptr) {
        print("Can't step out of main function\n");
      } else {
        run_until.f = self->ctx->prev_ctx->f;
        run_until.ins_id = self->ctx->prev_ctx->cur_instr;
        running = true;
      }
    } else if (strcmp(last.inner.data, "stack") == 0) {
      __print_stack(cur_ctx, &self->memory[MK_STACK]);
    } else if (strcmp(last.inner.data, "heap") == 0) {
//                 args = cmd.split(" ")[1:]
//                 if len(args) == 0:
//                     print(self.memory[MemKind.HEAP.value])
//                     continue
//                 offset = 0
//                 if args[0].startswith("0x"):
//                     offset = int(args[0][2:], base=16)
//                 else:
//                     offset = int(args[0])
//                 print(self.memory[MemKind.HEAP.value][offset:])
    } else if (strcmp(last.inner.data, "globals") == 0) {
      __print_globals(self->globals, self->globals_len, &self->memory[MK_GLOB]);
    } else if (strcmp(last.inner.data, "func") == 0) {
//                 def p(name, f):
//                     print(f"function {name}:")
//                     for i, ins in enumerate(f.instructions):
//                         print(f"#{i:03} {ins}")
// 
//                 args = cmd.split(" ")[1:]
//                 if len(args) == 0:
//                     p(cur_ctx.f_name, cur_ctx.cur_function)
//                 else:
//                     f_name = args[0]
//                     if f_name not in self.functions.keys():
//                         print(f"Unknown function '{f_name}'")
//                         continue
//                     f = self.functions[f_name]
//                     p(f_name, f)
    } else if (strcmp(last.inner.data, "call_stack") == 0) {
      __print_call_stack(cur_ctx, self->ctx);
    } else if (__strcmp2(&last, "u", "up")) {
      print_ins = __call_stack_navigate(&cur_ctx, self->ctx, -1);
    } else if (__strcmp2(&last, "d", "down")) {
      print_ins = __call_stack_navigate(&cur_ctx, self->ctx, 1);
    } else if (strcmp(last.inner.data, "exit") == 0) {
      return;
    }
  }
}
