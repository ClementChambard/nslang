#include ir.nsh

fn __optimize_push_ops(instrs: IrInstr*, instr_cnt: u64*) -> bool {
  let offset: i64;
  let i: i64;
  offset = 0;
  i = 0;
  
  while (i < *instr_cnt) {
    if (i != *instr_cnt - 1) if (instrs[i].opcode == IR_PSH) if (instrs[i].operand1 <= IR_OPK_ADDR) if (instrs[i + 1].operand1 == IR_OPK_NONE) {
      let next: IrInstr*;
      next = &instrs[i + 1];
      if (next->opcode >= IR_ADD) {
        next->operand1 = instrs[i].operand1;
        next->operand2 = instrs[i].operand2;
        offset += 1;
        i += 1;
        continue;
      }
    }
    
    if (offset != 0) {
      instrs[i - offset].move_from(&instrs[i]);
    }

    i += 1;
  }

  *instr_cnt = *instr_cnt - offset;
  return offset != 0;
}

fn __optimize_nooplike_ops(instrs: IrInstr*, instr_cnt: u64*) -> bool {
  let offset: i64;
  let i: i64;
  offset = 0;
  i = 0;
  
  while (i < *instr_cnt) {
    if (instrs[i].opcode == IR_ADD) if (instrs[i].operand1 == IR_OPK_IMM) if (instrs[i].operand2 == 0) {
      offset += 1;
      i += 1;
      continue;
    }
    if (instrs[i].opcode == IR_SUB) if (instrs[i].operand1 == IR_OPK_IMM) if (instrs[i].operand2 == 0) {
      offset += 1;
      i += 1;
      continue;
    }
    if (instrs[i].opcode == IR_SHL) if (instrs[i].operand1 == IR_OPK_IMM) if (instrs[i].operand2 == 0) {
      offset += 1;
      i += 1;
      continue;
    }
    if (instrs[i].opcode == IR_SHR) if (instrs[i].operand1 == IR_OPK_IMM) if (instrs[i].operand2 == 0) {
      offset += 1;
      i += 1;
      continue;
    }
    if (instrs[i].opcode == IR_IOR) if (instrs[i].operand1 == IR_OPK_IMM) if (instrs[i].operand2 == 0) {
      offset += 1;
      i += 1;
      continue;
    }
    if (instrs[i].opcode == IR_XOR) if (instrs[i].operand1 == IR_OPK_IMM) if (instrs[i].operand2 == 0) {
      offset += 1;
      i += 1;
      continue;
    }
    if (instrs[i].opcode == IR_MUL) if (instrs[i].operand1 == IR_OPK_IMM) if (instrs[i].operand2 == 1) {
      offset += 1;
      i += 1;
      continue;
    }
    if (instrs[i].opcode == IR_DIV) if (instrs[i].operand1 == IR_OPK_IMM) if (instrs[i].operand2 == 1) {
      offset += 1;
      i += 1;
      continue;
    }

    if (offset != 0) {
      instrs[i - offset].move_from(&instrs[i]);
    }

    i += 1;
  }
  
  *instr_cnt = *instr_cnt - offset;
  return offset != 0;
}

fn __optimize_push_drop(instrs: IrInstr*, instr_cnt: u64*) -> bool {
  let offset: i64;
  let i: i64;
  offset = 0;
  i = 0;
  
  while (i < *instr_cnt) {

    if (i != *instr_cnt - 1) if (instrs[i].opcode == IR_PSH) if (instrs[i + 1].opcode == IR_DRP) {
      offset += 2;
      i += 2;
      continue;
    }
    
    if (offset != 0) {
      instrs[i - offset].move_from(&instrs[i]);
    }

    i += 1;
  }

  *instr_cnt = *instr_cnt - offset;
  return offset != 0;
}

fn __optimize_funcion_ir(ir: IrFunc*) {
  if (ir->instructions_len == 0) return;
  let changed: bool;
  changed = true;
  while (changed) {
    changed = false;
    changed |= __optimize_push_drop(ir->instructions, &ir->instructions_len);
    changed |= __optimize_nooplike_ops(ir->instructions, &ir->instructions_len);
    changed |= __optimize_push_ops(ir->instructions, &ir->instructions_len);
  }
}

fn FullIr::optimize(self: FullIr*) {
  let i: i64;
  i = 0;
  while (i < self->functions_len) {
    __optimize_funcion_ir(&self->functions[i]);
    i += 1;
  }
}
