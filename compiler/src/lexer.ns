#include lexer.nsh
#include loc.nsh
#include mem.nsh
#include str.nsh
#include file.nsh
#include io.nsh
#include diags.nsh
#include opened_file.nsh

fn Lexer::init(self: Lexer*) {
    self->cur_lexer = nullptr;
    self->lexer_stack.init();
    self->cached_tokens.init();
    self->include_paths.init();
    self->already_included_files.init();
}

fn Lexer::delete(self: Lexer*) {
    let i: i64;
    if (self->cur_lexer != nullptr) free(self->cur_lexer);
    i = 0; while (i < self->lexer_stack.len) { free(self->lexer_stack[i]); i += 1; }
    self->lexer_stack.destroy();
    i = 0; while (i < self->cached_tokens.len) { free(self->cached_tokens[i]); i += 1; }
    self->cached_tokens.destroy();
    i = 0; while (i < self->include_paths.len) { free(self->include_paths[i]); i += 1; }
    self->include_paths.destroy();
    i = 0; while (i < self->already_included_files.len) { free(self->already_included_files[i]); i += 1; }
    self->already_included_files.destroy();
}

fn Lexer::add_include_path(self: Lexer*, path: i8*) {
    self->include_paths.push(strdup(path));
}

fn __find_file_to_include_relative(self: Lexer*, filename: i8*, filename_len: i64, loc: Loc) -> i8* {
    let result: i8*;
    let i: i64;

    // add current directory
    let cur_dir: Str;
    let slash_pos: i64;
    cur_dir.from_cstr(self->cur_lexer->f->filename);
    slash_pos = -1;
    i = 0;
    while (i < cur_dir.len) {
        if (cur_dir.data[i] == '/') slash_pos = i;
        i += 1;
    }
    if (slash_pos != -1) {
       let cur_dir_tmp: i8*;
       cur_dir_tmp = malloc(slash_pos + 1);
       memcpy(cur_dir_tmp, cur_dir.data, slash_pos);
       cur_dir_tmp[slash_pos] = 0;
       self->include_paths.push(cur_dir_tmp);
    } else {
       // no slasn, then '.'
       self->include_paths.push(strdup("."));
    }

    // check possible file paths
    i = 0;
    result = nullptr;
    while (i < self->include_paths.len) {
        let dir_len: i64;
        dir_len = strlen(self->include_paths[i]);
        let tmp_result: i8*;
        tmp_result = malloc(filename_len + 2 + dir_len);
        memcpy(tmp_result, self->include_paths[i], dir_len);
        tmp_result[dir_len] = '/';
        memcpy(&tmp_result[dir_len+1], filename, filename_len);
        tmp_result[dir_len + 1 + filename_len] = 0;

        // check file exists
        // TODO: better method ?
        let open_res: i64;
        open_res = open(tmp_result, O_RDWR, 0);
        if (open_res > 0) {
            close(open_res);
            result = tmp_result;
            break;
        }

        free(tmp_result);
        i += 1;
    }

    // remove current directory if it was added
    if (slash_pos != -1) {
        free(self->include_paths.pop());
    }

    // if not found, error and include nothing
    if (result == nullptr) {
        let msg: String;
        let filename_str: Str;
        filename_str.data = filename;
        filename_str.len = filename_len;
        msg.format("File '%S' can't be included (not found)", &filename_str);
        // let lc: CompleteLoc;
        // OpenedFile::get_loc(&lc, loc);
        // print("%s:%i:%i: %S\n", lc.filename, lc.line, lc.col, &msg);
        diag(loc, msg.data, DIAG_ERROR);
        msg.destroy();
        return strdup("/dev/null");
    }
    return result;
}

fn __find_file_to_include(self: Lexer*, filename: i8*, filename_len: i64, loc: Loc) -> i8* {
    let result: i8*;
    let i: i64;

    // if filename is absolute path, return it
    if (filename[0] == '/') {
        result = malloc(filename_len + 1);
        result[filename_len] = 0;
        memcpy(result, filename, filename_len);
    } else {
        result = __find_file_to_include_relative(self, filename, filename_len, loc);
    }

    // check if it was already included
    i = 0;
    while (i < self->already_included_files.len) {
        if (strcmp(result, self->already_included_files[i]) == 0) {
            free(result);
            return strdup("/dev/null");
        }
        i += 1;
    }

    // add it to included list and return it
    self->already_included_files.push(result);
    return result;
}

fn Lexer::enter_token(self: Lexer*, token: Token*) {
    self->cached_tokens.push(token);
}

fn Lexer::enter_source_file(self: Lexer*, filename: i8*) {
    if (self->cur_lexer != nullptr) {
        self->lexer_stack.push(self->cur_lexer);
    }
    self->cur_lexer = FileLexer::create(filename, self);
}

fn Lexer::end_source_file(self: Lexer*, token: Token*) {
    if (self->cur_lexer == nullptr) {
        return;
    }
    if (self->lexer_stack.len == 0) {
        self->cur_lexer->construct_token(token, self->cur_lexer->pos + 1, TOK_EOF);
        return;
    }
    free(self->cur_lexer);
    self->cur_lexer = cast<FileLexer*>(self->lexer_stack.pop());
    self->cur_lexer->lex_internal(token);
}

fn Lexer::handle_directive(self: Lexer*, token: Token*) {
    let dir_kind: Str;
    self->cur_lexer->read_to_whitespace(&dir_kind);
    if (dir_kind.len != 7) {
        print("Directive is not include !!! %s\n", dir_kind.data);
        return;
    }
    if (memcmp(dir_kind.data, "include", 7) != 0) {
        print("Directive is not include !!!");
        return;
    }

    self->cur_lexer->read_to_end_of_line(&dir_kind);
    dir_kind.strip();
    let include_file: i8*;
    include_file = __find_file_to_include(self, dir_kind.data, dir_kind.len, token->loc);
    self->enter_source_file(include_file);
    self->cur_lexer->lex_internal(token);
}

fn Lexer::handle_ident(self: Lexer*, token: Token*, ident_info: IdentInfo*) {}

fn Lexer::lex(self: Lexer*) -> Token* {
    if (self->cached_tokens.len != 0) {
        return self->cached_tokens.pop_front();
    }
    if (self->cur_lexer == nullptr) return nullptr;
    return self->cur_lexer->lex();
}
