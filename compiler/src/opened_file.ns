#include io.nsh
#include str.nsh
#include mem.nsh
#include file.nsh
#include opened_file.nsh
#include darray.nsh

let OPENED_FILES: DArray;

fn OpenedFile::line_offset(self: OpenedFile*, line: i64) -> i64 {
    if (line == 0) return 0;
    return self->line_cache[line - 2];
}

fn OpenedFile::make_line_cache(self: OpenedFile*) {
    let cache = DArray::init();

    self->line_cache_len = 0;
    let i = 0;
    while (i < self->source.len) {
        if (self->source[i] == '\r') {
            i += 1;
            if (self->source[i] == '\n') i += 1;
            cache.push(cast<void*>(i));
            continue;
        }
        if (self->source[i] == '\n') {
            i += 1;
            if (self->source[i] == '\r') i += 1;
            cache.push(cast<void*>(i));
            continue;
        }
        i += 1;
    }

    self->line_cache_len = cache.len;
    self->line_cache = cast<i64*>(cache.data);
    // don't destroy 'cache' since data has been transfered
}

fn OpenedFile::open(filename: i8*) -> OpenedFile* {
    let self = cast<OpenedFile*>(malloc(sizeof(OpenedFile)));
    self->filename = filename;
    let fd = open(filename, O_RDONLY, 0);
    if (fd <= 0) {
        print("OpenedFile::open: INVALID FILE NAME '%s'\n", filename);
        return nullptr;
    }
    self->source.len = lseek(fd, 0, SEEK_END) + 1;
    lseek(fd, 0, SEEK_SET);
    self->source.data = malloc(self->source.len);
    read(fd, self->source.data, self->source.len - 1);
    let tst_a = filename;
    close(fd);
    self->source[self->source.len - 1] = 0;
    self->make_line_cache();

    if (OPENED_FILES.len == 0) {
        self->pos_offset = 1;
    } else {
        let last_opened_file = cast<OpenedFile*>(OPENED_FILES[OPENED_FILES.len - 1]);
        self->pos_offset = last_opened_file->pos_offset + last_opened_file->source.len;
    }
    OPENED_FILES.push(self);
    return self;
}

fn OpenedFile::delete(self: OpenedFile*) {
    free(self->source.data);
    free(self->line_cache);
}

fn OpenedFile::close_all() {
    let i = 0;
    while (i < OPENED_FILES.len) {
        let cur_f = cast<OpenedFile*>(OPENED_FILES[i]);
        cur_f->delete();
        free(cur_f);
        i += 1;
    }
    OPENED_FILES.destroy();
}

fn OpenedFile::find(filename: i8*) -> OpenedFile* {
    let i = 0;
    while (i < OPENED_FILES.len) {
        let this_opened_file = cast<OpenedFile*>(OPENED_FILES[i]);
        if (strcmp(this_opened_file->filename, filename) == 0) return this_opened_file;
        i += 1;
    }
    return nullptr;
}

fn OpenedFile::find_by_loc(loc: Loc) -> OpenedFile* {
    if (loc == 0) return nullptr;
    if (OPENED_FILES.len == 0) return nullptr;
    let file_i = 0;
    while (file_i + 1 < OPENED_FILES.len) {
        if (loc < cast<OpenedFile*>(OPENED_FILES[file_i + 1])->pos_offset) break;
        file_i += 1;
    }
    return cast<OpenedFile*>(OPENED_FILES[file_i]);
}

fn OpenedFile::get_loc(out: CompleteLoc*, loc: Loc) {
    let f = OpenedFile::find_by_loc(loc);
    if (f == nullptr) return;
    let offset = loc - f->pos_offset;
    out->line = 0;
    out->col = offset;
    out->filename = f->filename;
    while (out->line < f->line_cache_len) {
        if (offset < f->line_cache[out->line]) break;
        out->line = out->line + 1;
    }
    if (out->line > 0) out->col = offset - f->line_cache[out->line - 1];
    out->line = out->line + 1;
    out->col = out->col + 1;
}
