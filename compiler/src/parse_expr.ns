#include ast_nodes_type.nsh
#include parse_type.nsh
#include parse_expr.nsh
#include diags.nsh
#include sema_expr.nsh
#include sema_constexpr.nsh
#include io.nsh
#include stdlib.nsh

fn prec_from_bin_op(tok: Tok) -> Prec {
  if (tok == TOK_EQUAL) return PREC_ASSIGN;
  if (tok == TOK_STAREQUAL) return PREC_ASSIGN;
  if (tok == TOK_SLASHEQUAL) return PREC_ASSIGN;
  if (tok == TOK_PERCENTEQUAL) return PREC_ASSIGN;
  if (tok == TOK_PLUSEQUAL) return PREC_ASSIGN;
  if (tok == TOK_MINUSEQUAL) return PREC_ASSIGN;
  if (tok == TOK_LESSLESSEQUAL) return PREC_ASSIGN;
  if (tok == TOK_GREATERGREATEREQUAL) return PREC_ASSIGN;
  if (tok == TOK_AMPEQUAL) return PREC_ASSIGN;
  if (tok == TOK_CARETEQUAL) return PREC_ASSIGN;
  if (tok == TOK_PIPEEQUAL) return PREC_ASSIGN;
  if (tok == TOK_QUESTION) return PREC_COND;
  if (tok == TOK_PIPEPIPE) return PREC_OR;
  if (tok == TOK_AMPAMP) return PREC_AND;
  if (tok == TOK_PIPE) return PREC_BOR;
  if (tok == TOK_CARET) return PREC_XOR;
  if (tok == TOK_AMP) return PREC_BAND;
  if (tok == TOK_EQUALEQUAL) return PREC_EQ;
  if (tok == TOK_EXCLAIMEQUAL) return PREC_EQ;
  if (tok == TOK_LESSEQUAL) return PREC_COMP;
  if (tok == TOK_LESS) return PREC_COMP;
  if (tok == TOK_GREATEREQUAL) return PREC_COMP;
  if (tok == TOK_GREATER) return PREC_COMP;
  if (tok == TOK_LESSLESS) return PREC_SHIFT;
  if (tok == TOK_GREATERGREATER) return PREC_SHIFT;
  if (tok == TOK_PLUS) return PREC_PLUS;
  if (tok == TOK_MINUS) return PREC_PLUS;
  if (tok == TOK_PERCENT) return PREC_STAR;
  if (tok == TOK_SLASH) return PREC_STAR;
  if (tok == TOK_STAR) return PREC_STAR;
  return PREC_UNKNOWN;
}

fn Parser::parse_expr(self: Parser *) -> Expr* { 
  let lhs: Expr*;
  lhs = self->parse_assignment_expr();
  return self->parse_rhs_of_binary_expr(lhs, PREC_COMMA);
}

fn Parser::parse_integer_constexpr(self: Parser *, loc: Loc*) -> i64 { 
  let e: Expr*;
  let rge: LocRge;
  e = self->parse_expr();
  cast<Stmt*>(e)->get_range(&rge);
  if (loc != nullptr) *loc = rge.end;
  if (!e->ty->is_integer_type()) {
    diag(rge.start, "Expected integer constexpr", DIAG_ERROR); // [e.get_range()];
    return 0;
  }
  return sema::eval_const_expr(e);
}

fn Parser::parse_expression_list(self: Parser *, exprs: Expr***, exprs_count: i64*) -> bool {
  let saw_error: bool;
  saw_error = false;
  let array: DArray;
  array.init();
  while (true) {
    let expr: Expr*;
    expr = nullptr;
    // if (self->tok->ty == TOK_LBRACE) {
    //   diag::warn_cxx98_compat_generalized_initializer_lists
    //   expr = parse_brace_initializer();
    // } else {
      expr = self->parse_assignment_expr();
    // }
    // if (self->tok->ty == TOK_ELLIPSIS) {
    //   expr = sema::act_on_pack_expansion(expr, self->consume_token());
    // }
    if (expr == nullptr) {
      saw_error = true;
      let skip_until_buf: Tok[2];
      skip_until_buf[0] = TOK_COMMA;
      skip_until_buf[1] = TOK_RPAREN;
      self->skip_until(skip_until_buf, 1, false, true);
    } else {
      array.push(expr);
    }
    if (self->tok->ty != TOK_COMMA) break;
    self->consume_token();
  }
  return saw_error;
  if (exprs != nullptr) *exprs = cast<Expr**>(array.data);
  if (exprs_count != nullptr) *exprs_count = array.len;
}

fn Parser::parse_postfix_expression_suffix(self: Parser *, lhs: Expr*) -> Expr* {
  let loc: Loc;
  loc = 0;
  while (true) {
    let ty: Tok;
    ty = self->tok->ty;
    if ((ty == TOK_PLUSPLUS) | (ty == TOK_MINUSMINUS)) {
      if (lhs != nullptr) {
        let arg: Expr*;
        arg = lhs;
        lhs = sema::act_on_postfix_unary_op(self->cur_scope, self->tok->loc, self->tok->ty, arg);
        if (lhs == nullptr) {
          // XXX: TODO
          // lhs = sema::create_recovery_expr(arg->get_begin_loc(), self->tok->loc, arg);
        }
      }
      self->consume_token();
    } else if (ty == TOK_LSQUARE) {
      let loc: Loc;
      let rloc: Loc;
      let arg_exprs: Expr**;
      let arg_count: i64;
      let had_error: bool;
      loc = self->consume_bracket();
      had_error = false;
      if (self->parse_expression_list(&arg_exprs, &arg_count)) {
        had_error = true;
      }
      rloc = self->tok->loc;
      if ((lhs != nullptr) & (!had_error) & (self->tok->ty == TOK_RSQUARE)) {
        lhs = sema::act_on_array_subscript_expr(self->cur_scope, lhs, loc, arg_exprs, arg_count, rloc);
      } else {
        lhs = nullptr;
      }
      self->consume_bracket();
    } else if (ty == TOK_LPAREN) {
      let loc: Loc;
      let arg_exprs: Expr**;
      let arg_count: i64;
      let skip_until_buf: Tok[1];
      arg_exprs = nullptr;
      arg_count = 0;
      skip_until_buf[0] = TOK_RPAREN;
      loc = self->consume_paren();
      if (self->tok->ty != TOK_RPAREN) {
        if (self->parse_expression_list(&arg_exprs, &arg_count)) {
          lhs = nullptr;
        }
      }
      if (lhs == nullptr) {
        self->skip_until(skip_until_buf, 1, true, false);
      } else if (self->tok->ty != TOK_RPAREN) {
        self->skip_until(skip_until_buf, 1, true, false);
        lhs = nullptr;
      } else {
        let fun: Expr*;
        fun = lhs;
        let rpar_loc: Loc;
        rpar_loc = self->consume_paren();
        lhs = sema::act_on_call_expr(self->cur_scope, fun, loc, arg_exprs, arg_count, rpar_loc);
        if (lhs == nullptr) {
          // XXX: TODO
          // arg_exprs = [fn] + arg_exprs
          // lhs = sema::create_recovery_expr(fn.get_range()[0], rpar_loc, arg_exprs)
        }
      }
    } else if ((ty == TOK_ARROW) | (ty == TOK_PERIOD)) {
      let opkind: Tok;
      let oploc: Loc;
      let orig_lhs: Expr*;
      let name: UnqualifiedId*;
      opkind = self->tok->ty;
      oploc = self->consume_token();
      orig_lhs = lhs;
      name = UnqualifiedId::new();
      if (self->parse_unqualified_id(name)) {
        lhs = nullptr;
      }
      if (lhs != nullptr) {
        lhs = sema::act_on_member_access_expr(self->cur_scope, lhs, oploc, opkind, nullptr, name);       
      }
      if (lhs == nullptr) if (orig_lhs != nullptr) if (name != nullptr) {
        // XXX: TODO
        // lhs = sema::create_recovery_expr(orig_lhs.get_range()[0], name.get_range()[1], [orig_lhs]);
      }
    } else {
      break;
    }
  }
  return lhs;
}

fn Parser::parse_unqualified_id(self: Parser *, out: UnqualifiedId*) -> bool {
  if (self->tok->ty != TOK_IDENT) {
        // kw_operator
        // tilde (for destructor name)
        // transform_type_trait => parse ident
    diag(self->tok->loc, "Expected unqualified identifier", DIAG_ERROR);
    return true;
  }
  let idinf: IdentInfo*;
  let idloc: Loc;
  idinf = cast<IdentInfo*>(self->tok->value);
  idloc = self->consume_token();
  out->set_identifier(idinf, idloc);
  return false;
}

fn Parser::parse_unit_expr(self: Parser *) -> Expr* {
  let res: Expr*;
  let saved_kind: Tok;
  res = nullptr;
  saved_kind = self->tok->ty;
  if (saved_kind == TOK_LPAREN) {
    let open_loc: Loc;
    open_loc = self->consume_paren();
    res = self->parse_expr();
    if (res != nullptr) if (self->tok->ty == TOK_RPAREN) {
      res = sema::act_on_paren_expr(open_loc, self->tok->loc, res);
    }
    if (res == nullptr) {
      let skip_buf: Tok[1];
      skip_buf[0] = TOK_RPAREN;
      self->skip_until(skip_buf, 1, true, false);
    } else {
      self->expect_and_consume(TOK_RPAREN, nullptr, nullptr);
    }
  } else if (saved_kind == TOK_NUM) {
    res = sema::act_on_numeric_constant(self->tok);
    self->consume_token();
  } else if ((saved_kind == TOK_KW_TRUE) | (saved_kind == TOK_KW_FALSE)) {
    res = sema::act_on_bool_literal(self->consume_token(), saved_kind);
  } else if (saved_kind == TOK_KW_NULLPTR) {
    res = sema::act_on_nullptr_literal(self->consume_token());
  } else if (saved_kind == TOK_KW_VAARG) {
    let start_loc: Loc;
    let end_loc: Loc;
    let ty: Type*;
    start_loc = self->consume_token();
    self->expect_and_consume(TOK_LESS, nullptr, nullptr);
    ty = self->parse_type();
    end_loc = self->tok->loc;
    self->expect_and_consume(TOK_GREATER, nullptr, nullptr);
    res = sema::act_on_vaarg_expr(ty, start_loc, end_loc);
  } else if (saved_kind == TOK_IDENT) {
    let ii: IdentInfo*;
    let iloc: Loc;
    let ss: StructType*;
    ii = cast<IdentInfo*>(self->tok->value);
    iloc = self->consume_token();
    ss = nullptr;
    if (self->tok->ty == TOK_COLONCOLON) {
      self->consume_token();
      if (self->tok->ty != TOK_IDENT) {
        print("TODO: error handling\n"); exit(1);
      }
      let scope_ii: IdentInfo*;
      let scope_loc: Loc;
      scope_ii = ii;
      scope_loc = iloc;
      ii = cast<IdentInfo*>(self->tok->value);
      iloc = self->consume_token();
      ss = sema::act_on_scoped_identifier(self->cur_scope, scope_ii, scope_loc);
    }
    let name: UnqualifiedId*;
    let replacement: Token*;
    name = UnqualifiedId::new();
    replacement = nullptr; // new Token
    name->set_identifier(ii, iloc);
    res = sema::act_on_id_expression(self->cur_scope, ss, name, self->tok->ty == TOK_LPAREN, replacement); // if self->tok->ty == TOK_RPAREN else None
    if (res == nullptr) {
      self->unconsume_token(replacement);
      return self->parse_unit_expr();
    }
  } else if (saved_kind == TOK_CHR) {
    res = sema::act_on_character_constant(self->tok);
    self->consume_token();
  } else if (saved_kind == TOK_STR) {
    let string_toks: DArray;
    string_toks.init();
    while (self->tok->ty == TOK_STR) {
      string_toks.push(self->tok);
      self->consume_any_token();
    }
    res = sema::act_on_string_literal(cast<Token**>(string_toks.data), string_toks.len);
  } else if ((saved_kind == TOK_PLUSPLUS) | (saved_kind == TOK_MINUSMINUS)) {
    let saved_loc: Loc;
    saved_loc = self->consume_token();
    res = self->parse_unit_expr();
    if (res != nullptr) {
      let arg: Expr*;
      arg = res;
      res = sema::act_on_unary_op(self->cur_scope, saved_loc, saved_kind, arg);
      if (res == nullptr) {
        // XXX: TODO
        // res = sema::create_recovery_expr(saved_tok2.loc, arg.get_range()[1], arg)
      }
    }
  } else if ((saved_kind == TOK_AMP) | (saved_kind == TOK_STAR) | (saved_kind == TOK_PLUS) | (saved_kind == TOK_MINUS) | (saved_kind == TOK_TILDE) | (saved_kind == TOK_EXCLAIM)) {
    let saved_loc: Loc;
    saved_loc = self->consume_token();
    res = self->parse_unit_expr();
    if (res != nullptr) {
      let arg: Expr*;
      arg = res;
      res = sema::act_on_unary_op(self->cur_scope, saved_loc, saved_kind, arg);
      if (res == nullptr) {
        // XXX: TODO
        // res = sema::create_recovery_expr(self->tok->loc, arg.get_range()[1], arg);
      }
    }
  } else if (saved_kind == TOK_KW_CAST) {
    let start_loc: Loc;
    let end_loc: Loc;
    let ty: Type*;
    let expr: Expr*;
    start_loc = self->consume_token();
    self->expect_and_consume(TOK_LESS, nullptr, nullptr);
    ty = self->parse_type();
    self->expect_and_consume(TOK_GREATER, nullptr, nullptr);
    self->expect_and_consume(TOK_LPAREN, nullptr, nullptr);
    expr = self->parse_expr();
    end_loc = self->tok->loc;
    self->expect_and_consume(TOK_RPAREN, nullptr, nullptr);
    res = sema::act_on_explicit_cast(ty, expr, start_loc, end_loc);
  } else if (saved_kind == TOK_KW_SIZEOF) {
    let start_loc: Loc;
    let end_loc: Loc;
    let ty: Type*;
    let expr: Expr*;
    start_loc = self->consume_token();
    self->expect_and_consume(TOK_LPAREN, nullptr, nullptr);
    ty = nullptr;
    expr = nullptr;
    if (self->is_start_of_type()) {
      ty = self->parse_type();
    } else {
      expr = self->parse_expr();
      ty = expr->ty;
    }
    if (ty == nullptr) {
      diag(start_loc, "sizeof on invalid type", DIAG_ERROR);
      ty = Type::get_builtin(BTK_I64);
    }
    end_loc = self->tok->loc;
    self->expect_and_consume(TOK_RPAREN, nullptr, nullptr);
    res = sema::act_on_sizeof_expr(ty, expr, start_loc, end_loc);
  }
  return self->parse_postfix_expression_suffix(res);
}

fn Parser::parse_assignment_expr(self: Parser *) -> Expr* {
  let lhs: Expr*;
  lhs = self->parse_unit_expr();
  return self->parse_rhs_of_binary_expr(lhs, PREC_ASSIGN);
}

fn Parser::parse_rhs_of_binary_expr(self: Parser *, lhs: Expr*, prec: Prec) -> Expr* {
  let next_tok_prec: Prec;
  let colon_loc: Loc;
  next_tok_prec = prec_from_bin_op(self->tok->ty);
  colon_loc = 0;
  while (true) {
    let op_token_ty: Tok;
    let op_token_loc: Loc;
    let ternary_middle: Expr*;
    if (next_tok_prec < prec) return lhs;
    op_token_ty = self->tok->ty;
    if (self->tok->ty == TOK_COMMA) {
      return lhs;
    }
    op_token_loc = self->consume_token();
    ternary_middle = nullptr;
    if (next_tok_prec == PREC_COND) {
      // if (self->tok->ty == TOK_LBRACE) {
        // // brace_loc = self.tok.loc
        // ternary_middle = parse_brace_initializer();
        // if (ternary_middle != nullptr) {
        //   diag(op_token_loc, "initializer list cannot be used on the left hand side of operator ':'", DIAG_ERROR)  // sema::get_expr_range(ternary_middle)
        //   ternary_middle = nullptr;
        // }
      // } else 
      if (self->tok->ty != TOK_COLON) {
        ternary_middle = self->parse_expr();
      } else {
        ternary_middle = nullptr;
        diag(op_token_loc, "ext_gnu_conditional_expr", DIAG_WARNING);
      }
      if (ternary_middle == nullptr) {
        lhs = nullptr;
        ternary_middle = nullptr;
      }
      if (!self->try_consume_token(TOK_COLON, &colon_loc)) {
        diag(op_token_loc, "expected ':'", DIAG_ERROR);
        diag(op_token_loc, "to match this '?'", DIAG_NOTE);
      }
    }
    let rhs: Expr*;
    rhs = nullptr;
    if (next_tok_prec <= PREC_COND) {
      rhs = self->parse_assignment_expr();
    } else {
      rhs = self->parse_unit_expr();
    }
    if (rhs == nullptr) {
      lhs = nullptr;
    }
    let this_prec: Prec;
    let is_right_assoc: bool;
    this_prec = next_tok_prec;
    next_tok_prec = prec_from_bin_op(self->tok->ty);
    is_right_assoc = (this_prec == PREC_COND) | (this_prec == PREC_ASSIGN);
    if ((this_prec < next_tok_prec) | ((this_prec == next_tok_prec) & is_right_assoc)) {
      let prec_new: i64;
      // XXX: weird cast with enums
      prec_new = cast<i64>(this_prec) + cast<i64>(!is_right_assoc);
      rhs = self->parse_rhs_of_binary_expr(rhs, cast<Prec>(prec_new));
      if (rhs == nullptr) lhs = nullptr;
      next_tok_prec = prec_from_bin_op(self->tok->ty);
    }
    let orig_lhs: Expr*;
    orig_lhs = lhs;
    if (lhs != nullptr) {
      if (ternary_middle == nullptr) {
        let bin_op: Expr*;
        bin_op = sema::act_on_bin_op(self->cur_scope, op_token_loc, op_token_ty, lhs, rhs);
        if (bin_op == nullptr) {
          // XXX: TODO
          // bin_op = sema::create_recovery_expr(lhs.get_range()[0], rhs.get_range()[1], [lhs, rhs]);
        }
        lhs = bin_op;
      } else {
        let cond_op: Expr*;
        cond_op = sema::act_on_conditional_op(op_token_loc, colon_loc, lhs, ternary_middle, rhs);
        if (cond_op == nullptr) {
          // XXX: TODO
          // args = []
          // if ternary_middle is not None:
          //     args = [lhs, ternary_middle, rhs]
          // else:
          //     args = [lhs, rhs]
          // cond_op = sema::create_recovery_expr(lhs.get_range()[0], rhs.get_range()[1], args)
        }
        lhs = cond_op;
      }
    }
  }
}
