#include parse_type.nsh
#include tok.nsh
#include io.nsh
#include stdlib.nsh
#include ast_nodes_type.nsh
#include ast_nodes_decl.nsh
#include ident_info.nsh
#include diags.nsh

lib fn Parser::parse_integer_constexpr(self: Parser *, end_loc: Loc*) -> i64;
 
fn Parser::parse_type(self: Parser *) -> Type* {
  let cur_type: Type* = nullptr;
  let no_type = true;
  while (true) {
    if (no_type) {
      if (tok_is_builtin_type(self->tok->ty)) {
        cur_type = BuiltinType::get_from_tok(self->tok);
        self->consume_token();
        no_type = false;
        continue;
      }
      if (self->tok->ty == TOK_KW_VOID) {
        no_type = false;
        self->consume_token();
        continue;
      }
      if (self->tok->ty == TOK_IDENT) {
        let type_name = cast<IdentInfo*>(self->tok->value)->val;
        let type_loc = self->consume_token();
        let decl = self->cur_scope->lookup_named_decl(type_name);
        if (decl == nullptr) {
          let s = String::format("'%s' is not a type name", type_name);
          diag(type_loc, s.data, DIAG_ERROR);
          s.destroy();
          return nullptr;
        }
        if (!cast<Decl*>(decl)->is_type()) {
          let s = String::format("'%s' is not a type name", type_name);
          diag(type_loc, s.data, DIAG_ERROR);
          s.destroy();
          return nullptr;
        }
        cur_type = cast<TypeDecl*>(decl)->ty;
        if (cur_type->kind == TYPEKIND_ENUM) if (cast<EnumType*>(cur_type)->aliased_type != nullptr) {
          cur_type = cast<EnumType*>(cur_type)->aliased_type;
        }
        continue;
      }
      return cur_type;
    }
    if (self->tok->ty == TOK_STAR) {
      cur_type = Type::get_pointer(cur_type);
      self->consume_token();
      continue;
    }
    if (self->tok->ty == TOK_LSQUARE) {
      self->consume_bracket();
      let count = self->parse_integer_constexpr(nullptr);
      self->expect_and_consume(TOK_RSQUARE, nullptr, nullptr);
      cur_type = Type::get_array(cur_type, count);
      continue;
    }
    break;
  }
  // ActOnTypeName -> TODO:
  return cur_type;
}

fn Parser::is_start_of_type(self: Parser *) -> bool {
  if (tok_is_builtin_type(self->tok->ty)) return true;
  if (self->tok->ty == TOK_KW_VOID) return true;
  if (self->tok->ty == TOK_IDENT) {
    let type_name = cast<IdentInfo*>(self->tok->value)->val;
    let decl = self->cur_scope->lookup_named_decl(type_name);
    if (decl == nullptr) return false;
    return cast<Decl*>(decl)->is_type();
  }
  return false;
}

fn Parser::following_is_type(self: Parser *, ctx: i64) -> bool {
  // TODO:
  return false;
}
