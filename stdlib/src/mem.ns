#include mem.nsh

let __curbrk: void *;

fn sbrk(size: i64) -> void* {
    let update_brk: bool = __curbrk == nullptr;

    if (update_brk) {
        __curbrk = cast<void*>(brk(nullptr));
        if (cast<i64>(__curbrk) < 0)
            return cast<void*>(-1);
    }

    if (size == 0)
        return __curbrk;

    let oldbrk: void* = __curbrk;

    if (size > 0) {
        if (cast<i64>(oldbrk) + size < cast<i64>(oldbrk)) {
            // overflow
            return cast<void*>(-1);
        }
    }
    if (size < 0) {
        if (cast<i64>(oldbrk) < -size) {
            return cast<void*>(-1);
        }
    }

    __curbrk = cast<void*>(brk(oldbrk + size));
    if (cast<i64>(__curbrk) < 0)
        return cast<void*>(-1);

    return oldbrk;
}

fn memcpy(dst: void*, src: void*, size: i64) -> void* {
    let dst_as_i8: i8* = dst;
    let src_as_i8: i8* = src;
    let i: i64 = 0;
    while (i < size) {
        dst_as_i8[i] = src_as_i8[i];
        ++i;
    }
    return dst;
}

fn memset(dst: void*, byte: i8, size: i64) -> void* {
    let dst_as_i8: i8* = dst;
    let i: i64 = 0;
    while (i < size) {
        dst_as_i8[i] = byte;
        ++i;
    }
    return dst;
}

fn memcmp(mem1: void*, mem2: void*, size: i64) -> i64 {
    let mem1_as_i8: i8* = mem1;
    let mem2_as_i8: i8* = mem2;
    let i: i64 = 0;
    while (i < size) {
        if (mem1_as_i8[i] != mem2_as_i8[i]) return mem1_as_i8[i] - mem2_as_i8[i];
        ++i;
    }
    return 0;
}

struct __malloc_block_meta {
    size: i64;
    next: __malloc_block_meta*;
    is_free: i64;
    magic: i64;
};

let __malloc_global_base: void *;

fn __malloc_find_free_block(last: __malloc_block_meta**, size: i64) -> __malloc_block_meta* {
    let current: __malloc_block_meta* = __malloc_global_base;
    while (true) {
        if (current == nullptr) {
            break;
        }
        if (current->is_free != 0) {
            if (current->size >= size) break;
        }
        *last = current;
        current = current->next;
    }
    return current;
}

fn __malloc_request_space(last: __malloc_block_meta*, size: i64) -> __malloc_block_meta* {
    let block: __malloc_block_meta* = sbrk(0);
    let request: void* = sbrk(size + sizeof(__malloc_block_meta));
    if (cast<i64>(request) == -1) {
        return nullptr;
    }
    if (request != block) {
        return nullptr;
    }
    if (last != nullptr) {
        last->next = block;
    }
    block->size = size;
    block->next = nullptr;
    block->is_free = 0;
    block->magic = 0x12345678;
    return block;
}

fn __malloc_block_to_data(block: __malloc_block_meta*) -> void* {
    return cast<void*>(block + 1);
}

fn __malloc_data_to_block(data: void*) -> __malloc_block_meta* {
    return cast<__malloc_block_meta*>(data) - 1;
}

fn malloc(size: i64) -> void* {
    let block: __malloc_block_meta*;
    if (size <= 0) {
        return nullptr;
    }

    if (__malloc_global_base == nullptr) {
        block = __malloc_request_space(nullptr, size);
        if (block == nullptr) {
            return nullptr;
        }
        __malloc_global_base = block;
    } else {
        let last: __malloc_block_meta*;
        last = __malloc_global_base;
        block = __malloc_find_free_block(&last, size);
        if (block == nullptr) {
            block = __malloc_request_space(last, size);
            if (block == nullptr) {
                return nullptr;
            }
        } else {
            block->is_free = 0;
            block->magic = 0x77777777;
        }
    }

    return __malloc_block_to_data(block);
}

fn free(block: void*) {
    if (block == nullptr) return;

    let meta: __malloc_block_meta* = __malloc_data_to_block(block);
    // assert(meta->is_free == 0)
    // assert(meta->magic == 0x12345678 || meta->magic == 0x77777777)
    meta->is_free = 1;
    meta->magic = 0x55555555;
}

fn realloc(ptr: void*, size: i64) -> void* {
    if (ptr == nullptr) {
        return malloc(size);
    }

    let block_ptr: __malloc_block_meta* = __malloc_data_to_block(ptr);
    if (block_ptr->size >= size) {
        return ptr;
    }

    let new_ptr: void* = malloc(size);
    if (new_ptr == nullptr) {
        return nullptr;
    }
    memcpy(new_ptr, ptr, block_ptr->size);
    free(ptr);
    return new_ptr;
}

fn calloc(nelem: i64, elsize: i64) -> void* {
    let size: i64 = nelem * elsize;
    let ptr: void* = malloc(size);
    memset(ptr, 0, size);
    return ptr;
}
