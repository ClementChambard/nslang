#include str.nsh
#include mem.nsh

fn isspace(c: char) -> bool {
    if (c == ' ') return true;
    if (c >= 0x9) if (c <= 0xd) return true;
    if (c >= 0x1c) if (c <= 0x1f) return true;
    return false;
}

fn strcmp(str_1: CStr, str_2: CStr) -> i64 {
    if (str_1 == str_2) return 0;
    while (*str_1 != 0) {
        if (*str_1 != *str_2) return *str_1 - *str_2;
        str_1 = &str_1[1];
        str_2 = &str_2[1];
    }
    return *str_1 - *str_2;
}

fn strlen(str: CStr) -> i64 {
    let len: i64;
    len = 0;
    while (str[len] != 0) len += 1;
    return len;
}

fn strdup(str: CStr) -> CStr {
    let len: i64;
    let out: CStr;
    len = strlen(str);
    out = malloc(len + 1);
    memcpy(out, str, len);
    out[len] = 0;
    return out;
}

fn strcat(str_1: CStr, str_2: CStr) -> CStr {
    let len_1: i64;
    let len_2: i64;
    let out: CStr;
    len_1 = strlen(str_1);
    len_2 = strlen(str_2);
    out = malloc(len_1 + len_2 + 1);
    memcpy(out, str_1, len_1);
    memcpy(&out[len_1], str_2, len_2);
    out[len_1 + len_2] = 0;
    return out;
}




fn Str::strip(self: Str*) {
    while (isspace(self->data[0])) {
        self->data = &self->data[1];
        self->len = self->len - 1;
    }
    while (isspace(self->data[self->len - 1])) {
        self->len = self->len - 1;
    }
}

fn Str::from_cstr(self: Str*, cstr: CStr) {
    self->len = strlen(cstr);
    self->data = cstr;
}

fn String::__alloc_more(self: String*) {
    if (self->capacity == 0) {
        self->capacity = 8;
    } else {
        self->capacity = self->capacity * 2;
    }
    self->data = realloc(self->data, self->capacity + 1);
}

fn String::init(self: String*) {
    self->len = 0;
    self->data = 0;
    self->capacity = 0;
}

fn String::destroy(self: String*) {
    if (self->data != nullptr) free(self->data);
    self->len = 0;
    self->data = nullptr;
    self->capacity = 0;
}

fn String::push(self: String*, c: char) {
    if (self->len + 1 > self->capacity) {
        String::__alloc_more(self);
    }
    self->data[self->len] = c;
    self->len = self->len + 1;
    self->data[self->len] = 0;
}

fn String::push_str(self: String*, s: Str*) {
    while (self->len + s->len > self->capacity) {
        self->__alloc_more();
    }
    memcpy(&self->data[self->len], s->data, s->len);
    self->len = self->len + s->len;
    self->data[self->len] = 0;
}

fn String::push_cstr(self: String*, s: CStr) {
    let str: Str;
    str.from_cstr(s);
    self->push_str(&str);
}


fn fmt_num(self: String*, num: i64, signed: bool) {
    let buf: char[22];
    let p: char*;
    let digit: i64;
    let neg: bool;

    if (signed) {
        neg = num < 0;
        if (neg) num = -num; // technically, this could overflow
    } else {
        neg = false;
    }

    p = &buf[21];
    *p = 0;
    do {
        p -= 1;
        digit = num % 10; // TODO: this assumes signed integers => some chars are invalid
        num /= 10;
        *p = digit + '0';
    } while (num != 0);

    if (neg) {
       p -= 1;
       *p = '-';
    }
    self->push_cstr(p);
}

fn fmt_hex(self: String*, num: i64, upper: bool) {
    let buf: char[19];
    let p: char*;
    let digit: i64;
    p = &buf[18];
    *p = 0;
    do {
        p -= 1;
        digit = num & 0xF;
        num >>= 4;
        if (digit <= 9) {
            *p = digit + '0';
        } else if (upper) {
            *p = digit + (-10 + 'A');
        } else {
            *p = digit + (-10 + 'a');
        }
    } while (num != 0);
    self->push_cstr(p);
}

fn String::format(self: String*, fmt: CStr, ...) { // TODO: forward varargs
    let i: i64;
    let last_i: i64;
    let str_to_add: Str;
    self->len = 0;
    self->data = nullptr;
    self->capacity = 0;

    i = 0;
    last_i = 0;

    while (fmt[i] != 0) {
        if (fmt[i] != '%') {
            i += 1;
            continue;
        }
        if (i != last_i) {
            str_to_add.len = i - last_i;
            str_to_add.data = &fmt[last_i];
            self->push_str(&str_to_add);
            last_i = i;
        }
        i += 1;
        if (fmt[i] == '%') {
            self->push('%');
        } else if (fmt[i] == 'i') {
            fmt_num(self, vaarg<i64>, true);
        } else if (fmt[i] == 'u') {
            fmt_num(self, vaarg<i64>, false);
        } else if (fmt[i] == 'x') {
            fmt_hex(self, vaarg<i64>, false);
        } else if (fmt[i] == 'X') {
            fmt_hex(self, vaarg<i64>, true);
        } else if (fmt[i] == 's') {
            self->push_cstr(vaarg<CStr>);
        } else if (fmt[i] == 'S') {
            self->push_str(vaarg<Str*>);
        } else if (fmt[i] == 'c') {
            self->push(vaarg<char>);
        }

        i += 1;
        last_i = i;
    }
    if (i != last_i) {
        str_to_add.len = i - last_i;
        str_to_add.data = &fmt[last_i];
        self->push_str(&str_to_add);
    }
}

fn String::push_format(self: String*, fmt: CStr, ...) {
    let i: i64;
    let last_i: i64;
    let str_to_add: Str;

    i = 0;
    last_i = 0;

    while (fmt[i] != 0) {
        if (fmt[i] != '%') {
            i += 1;
            continue;
        }
        if (i != last_i) {
            str_to_add.len = i - last_i;
            str_to_add.data = &fmt[last_i];
            self->push_str(&str_to_add);
            last_i = i;
        }
        i += 1;
        if (fmt[i] == '%') {
            self->push('%');
        } else if (fmt[i] == 'i') {
            fmt_num(self, vaarg<i64>, true);
        } else if (fmt[i] == 'u') {
            fmt_num(self, vaarg<i64>, false);
        } else if (fmt[i] == 'x') {
            fmt_hex(self, vaarg<i64>, false);
        } else if (fmt[i] == 'X') {
            fmt_hex(self, vaarg<i64>, true);
        } else if (fmt[i] == 's') {
            self->push_cstr(vaarg<CStr>);
        } else if (fmt[i] == 'S') {
            self->push_str(vaarg<Str*>);
        } else if (fmt[i] == 'c') {
            self->push(vaarg<char>);
        }

        i += 1;
        last_i = i;
    }
    if (i != last_i) {
        str_to_add.len = i - last_i;
        str_to_add.data = &fmt[last_i];
        self->push_str(&str_to_add);
    }
}

fn String::insert(self: String*, idx: i64, c: char) {
    if (idx >= self->len) {
        self->push(c);
        return;
    }
    if (idx < 0) idx = 0;
    if (self->len + 1 > self->capacity) {
        self->__alloc_more();
    }
    let i: i64;
    i = self->len;
    while (i >= idx) {
        self->data[i + 1] = self->data[i];
        i -= 1;
    }
    self->data[idx] = c;
    self->len = self->len + 1;
}

fn String::insert_str(self: String*, idx: i64, str: Str*) {
    if (idx >= self->len) {
        self->push_str(str);
        return;
    }
    if (idx < 0) idx = 0;
    while (self->len + str->len > self->capacity) {
        self->__alloc_more();
    }
    let i: i64;
    i = self->len;
    while (i >= idx) {
        self->data[i + str->len] = self->data[i];
        i -= 1;
    }
    memcpy(&self->data[idx], str->data, str->len);
    self->len = self->len + str->len;
}

fn String::insert_cstr(self: String*, idx: i64, cstr: CStr) {
    let s: Str;
    s.from_cstr(cstr);
    self->insert_str(idx, &s);
}

fn String::split_off(self: String*, idx: i64, out: String*) {
    if (idx >= self->len) {
        String::init(out);
        return;
    }
    if (idx <= 0) {
        out->inner.len = self->len;
        out->inner.data = self->data;
        out->capacity = self->capacity;
        String::init(self);
        return;
    }
    let remainder: Str;
    remainder.len = self->len - idx;
    remainder.data = &self->data[idx];
    out->from_str(&remainder);
    self->truncate(idx);
}

fn String::clear(self: String*) { self->len = 0; }

fn String::clone_from(self: String*, clone_from: String*) {
    self->len = clone_from->inner.len;
    self->capacity = clone_from->capacity;
    self->data = malloc(self->capacity + 1);
    memcpy(self->data, clone_from->inner.data, self->len);
    self->data[self->len] = 0;
}

fn String::reserve(self: String*, count: i64) {
    if (self->capacity > count) return;
    self->capacity = count;
    self->data = realloc(self->data, self->capacity);
}

fn String::shrink_to_fit(self: String*) {
    if (self->capacity == self->len) return;
    let new_buf: char*;
    new_buf = malloc(self->len + 1);
    memcpy(new_buf, self->data, self->len + 1);
    free(self->data);
    self->capacity = self->len;
    self->data = new_buf;
}

fn String::truncate(self: String*, count: i64) {
    if (self->len > count) self->len = count;
}

fn String::pop(self: String*) -> char {
    let out: char;
    out = self->data[self->len - 1];
    self->len = self->len - 1;
    return out;
}

fn String::remove(self: String*, idx: i64) -> char {
    if (idx >= self->len) {
        return self->pop();
    }
    if (idx < 0) idx = 0;
    let out: char;
    out = self->data[idx];
    let i: i64;
    i = idx;
    while (i < self->len) {
        self->data[i] = self->data[i + 1];
        i += 1;
    }
    self->len = self->len - 1;
    return out;
}

fn String::from_str(self: String*, str: Str*) {
    self->capacity = str->len;
    self->len = str->len;
    self->data = malloc(str->len + 1);
    memcpy(self->data, str->data, str->len);
    self->data[self->len] = 0;
}

fn String::from_cstr(self: String*, cstr: CStr) {
    let s: Str;
    s.from_cstr(cstr);
    self->from_str(&s);
}

fn String::from_raw_parts(self: String*, data: char*, len: i64, capacity: i64) {
    self->data = data;
    self->len = len;
    self->capacity = capacity;
}
